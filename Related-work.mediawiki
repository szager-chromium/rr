This page is in a somewhat disorganized state, please bear with us.

== Userspace recording ==

No target recompilation or VM hypervisor required.

[http://code.google.com/p/chronomancer/ Chronomancer]/[http://code.google.com/p/chronicle-recorder/ Chronicle]

[http://sourceware.org/gdb/wiki/ReverseDebug gdb reverse debugging] ([http://sourceware.org/gdb/wiki/ProcessRecord "process recorder"])

cjones: <blockquote>
Process record and replay works by logging the execution of each machine instruction in the child process (the program being debugged), together with each corresponding change in machine state (the values of memory and registers).
</blockquote>
* unclear how modification of user memory during syscalls is recorded (apparently not at all)
* unclear how process-shared memory is dealt with (apparently not at all)
* very very high overhead (singlesteps the program using ptrace)
* good approach for efficient replaying reverse-step et al.

[http://undo-software.com/ UndoDB]
* Similar design to rr: records whole Linux process
* Relies on code instrumentation in some manner
* Single-core execution
* Currently (4.0.3363) crashes when trying to record Firefox
* Integrates with gdb and some other similar debuggers
* Offers "Live Recorder" which you link into your program and lets you turn on recording in the field

[http://www.roguewave.com/getattachment/3a1cae85-60df-48a5-810a-8ff27344afd6/Finding-Hard-to-Reproduce-Bugs-Reverse-Debugging?sitename=RogueWave RogueWave TotalView ReplayEngine]

Sounds similar to rr/UndoDB but no mention of performance counters (in 2008 they probably didn't work anyway). Seems to use code instrumentation according to http://bgq1.epfl.ch/totalview/ReplayEngine_Getting_Started_Guide.pdf.

[http://research.cs.wisc.edu/areas/pl/seminar/fall05/Bhansali.ppt Nirvana]

[http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=797078D41476F33C75D5E95C4F8D5042?doi=10.1.1.92.8688&rep=rep1&type=pdf TORNADO]

[http://www.scs.stanford.edu/~dm/home/papers/mashtizadeh:castor.pdf Castor]
* Supports multithreading
* Based on library interception and a compiler plugin to instrument atomic operations
* Would require customization of JIT routines that emit atomic ops

[https://arxiv.org/pdf/1804.01226.pdf iReplay]
* Supports multithreading
* Library interception; assumes all synchronizing operations go through library calls
* Only replays "in situ" since last "stop the world" epoch. Can't replay across an epoch boundary
* Assumes no races; if divergence detected, just naively tries to replay hoping this will get the right schedule

== In-Kernel Userspace Recording ==

[https://homes.cs.washington.edu/~luisceze/publications/osdi10-dos.pdf Deterministic Process Groups in dOS]

[http://home.gna.org/jockey/ Jockey]

[https://www.usenix.org/system/files/conference/osdi14/osdi14-paper-devecsery.pdf Arnold] Low-overhead multicore record and replay based on instrumenting pthreads APIs (and atomics?) and assuming there are no data races.

[http://seclab.illinois.edu/wp-content/uploads/2019/05/hojjati2019distributed.pdf BEEER] "BEEER: distributed record and replay for medical devices in hospital operating rooms". Extending Arnold to track inter-machine communication.

== Full-System recording ==

[http://www.cs.uiuc.edu/homes/kingst/Research_files/dunlap02.pdf ReVirt]

[http://blogs.vmware.com/workstation/2008/04/enhanced-execut.html VMWare Record & Replay]
* Project canceled

[http://xenon.stanford.edu/~talg/papers/VEE10/crosscut-vee2010.pdf Crosscut] builds on the VMWare system and lets you "relog" to generate new logs during replay, including leveraging Chronicle to generate a Chronicle database!

[https://github.com/moyix/panda/blob/master/docs/record_replay.md PANDA]

[http://www.cs.utah.edu/~aburtsev/xen-tt-doc/ Xen-TT]; [https://www.flux.utah.edu/download?uid=225 VEE paper]

[http://wiki.qemu.org/Features/record-replay QEMU]

[https://sourceware.org/ml/gdb/2009-08/msg00170.html Simics]

== Performance Counters ==

[http://web.eece.maine.edu/~vweaver/projects/deterministic/deterministic_counters.pdf Non-Determinism and Overcount on Modern Hardware Performance Counter Implementations (Weaver, Terpstra, Moore)]

[http://groups.csail.mit.edu/commit/papers/09/asplos073-olszewski.pdf Kendo: Efficient Deterministic Multithreading in Software]
Out of date with its observations on performance counter behavior, but first paper to use performance counters for async event timing AFAIK.

== Language/VM-specific Replay ==

[https://developer.mozilla.org/en-US/docs/Mozilla/Projects/WebReplay WebReplay]

[https://github.com/nodejs/node-chakracore/blob/xplat/TTD-README.md ChakraCore NodeJS Debugger]

[http://everythingsysadmin.com/2014/04/time-travel-pdb.html Python Time Travel Debugger]

[http://chrononsystems.com Chronon]
* Similar to Chronomancer for Java.
* Chronon instruments bytecode to record variable changes and memory writes. Raw trace data goes to helper threads which use carefully optimized compression.
* It's unclear, but there's an "unpacker" step that probably performs some kind of indexing.
* Overheads quoted in [http://www.slideshare.net/tsauerwein/chronon-a-backintimedebugger-for-java this slide deck] range from >200x (even more than Chronomancer) for well-optimized Java code that's CPU bound, down to 2x when you spend plenty of time in I/O or code that's excluded from Chronon instrumentation. That's probably a reasonable thing to do for J2EE code, and they get to use multiple cores to run the application.
* There's a tradeoff between the scope of code recorded and the overhead of recording [http://chrononsystems.com/blog/choosing-what-to-record-part-1-controlling-pe described here].
* Scalability issues mentioned [http://blog.jetbrains.com/idea/2014/03/try-chronon-debugger-with-intellij-idea-13-1-eap/#comment-55286 here].
* Prediction-based compression described [http://chrononsystems.com/blog/chronon-3-recorder-internals here]
* For something like Firefox, where you really want to instrument the entire software stack and parallelism is not a big issue, rr's approach seems much better.
* No divergence support: of course Java VMs don't support cloning, so they could only implement divergence using emulation, but you'd need a lot of heap data to make that work reliably.

== GUI-level Record And Replay ==

[http://www.cs.ucr.edu/~neamtiu/pubs/oopsla15hu.pdf Valera]

[http://www.cs.ucr.edu/~neamtiu/pubs/icse13gomez.pdf Reran]

== Omniscient debugging ==

[https://github.com/BinaryAnalysisPlatform/qira Qira] Pretty naive impleemntation.

[https://www.tetrane.com/index.html Tetrane] Looks like a great implementation of omniscience. Focused on reverse-engineering applications so has a quite different feature set to Pernosco.

== (Not yet categorized) ==

[https://www.usenix.org/system/files/osdi18-cui.pdf REPT]
* REPT captures recent control flow via Intel PT and stores that in a crash dump, then reconstructs data values
* Integrates into WinDbg
* Sometimes produces incorrect results, which could be bad
* Obviously not as good as a proper recording if you can afford the overhead, but seems like a great addition for crash reporting

[http://www.cs.columbia.edu/~nieh/pubs/sigmetrics2010_scribe.pdfâ€Ž Scribe]

roc:
<blockquote>
There are a few major differences between Scribe and rr:
* Scribe doesn't serialize all threads. Instead they do a bunch of work to make sure all threads can run simultaneously. This reduces overhead in some places and adds overhead in others.
* They say their approach doesn't require "changing, relinking or recompiling the kernel" but their approach has to track internal kernel state like inodes and VFS path traversal, and it's not really clear how they do that. They also say "Scribe records by intercepting all interactions of processes with their environment, capturing all nondeterminism in events that are stored in log queues inside the kernel" so my guess is they're using a kernel module. That's a pretty big negative in my view.
* Scribe doesn't use performance counters to record asynchronous events. Instead they defer signal delivery until the next time the process enters the kernel. If the process doesn't enter the kernel for a long time, they basically take a snapshot of the entire state, force the process into the kernel and restart recording --- extremely heavyweight. For some bugs, it's essential to allow async signal delivery at any program point, so I don't like Scribe's approach there.
</blockquote>

[http://cseweb.ucsd.edu/~calder/papers/thesis-satish.pdf iDNA]

[http://dl.acm.org/citation.cfm?id=1772954.1772958 Pinplay]

[http://web.eecs.umich.edu/~nsatish/papers/ASPLOS-10-Respec.pdf Respec]

[http://www.mnis.fr/fr/services/virtualisation/pdf/ekatrinaitskova.pdf Echo]

[http://web.eecs.umich.edu/virtual/papers/king03.pdf OS Support]

[http://css.csail.mit.edu/6.858/2012/readings/backtracking.pdf BackTracker]

[http://static.usenix.org/event/usenix05/tech/general/king/king.pdf Time-Traveling Virtual Machines]

[https://web.eecs.umich.edu/~pmchen/papers/lucchetti05.pdf ExtraVirt]

[http://web.eecs.umich.edu/~pmchen/papers/king06.pdf SubVirt]

[https://cs.uwaterloo.ca/~brecht/courses/702/Possible-Readings/debugging/execution-replay-for-mp-vms-vee-2008.pdf SMP-ReVirt]

[http://notrump.eecs.umich.edu/papers/asplos23-nightingale.pdf Speck]

[http://www-personal.umich.edu/~jouyang/veeraraghavan11.pdf DoublePlay]

See [http://read.seas.harvard.edu/cs261/2011/doubleplay.html this page].

[http://www-mount.ece.umn.edu/~jjyi/MoBS/2007/program/01C-Xu.pdf ReTrace]

[http://www.jeffhuang.tk/academic/clap.pdf CLAP]

[https://parasol.tamu.edu/~jeff/academic/h3.pdf H3]

[http://iacoma.cs.uiuc.edu/iacoma-papers/asplos09.pdf Capo]

[http://iacoma.cs.uiuc.edu/iacoma-papers/isca13_1.pdf QuickRec / Capo3]

[https://www.usenix.org/legacy/event/usenix04/tech/general/full_papers/srinivasan/srinivasan_html/paper.html FlashBack]

ORDER: Object centRic DEterministic Replay for Java

PRES: Probabilistic replay with execution sketching on multiprocessors

[https://www.cs.purdue.edu/homes/xyzhang/Comp/ecoop14.pdf Infrastructure-Free Logging and Replay of Concurrent
Execution on Multiple Cores]
A bit like ODR; records some input syscalls while allowing threads to run concurrently, then detects divergence and searches for shared-memory races that allow for alternative schedules that would fix the divergence.

[https://www.usenix.org/system/files/conference/osdi12/osdi12-final-117.pdf Dune]
cjones:
<blockquote>
This isn't a record/replay tool per se, but rather creates a framework on which one could be built.  The elevator pitch is approximately that Dune exposes hardware virtualization features to userspace.  So userspace can manage its own page tables, directly process exceptions, and so forth.  With those tools, one could build a userspace-only ptrace equivalent.  And that, in theory, could allow building an rr-like tool without rr's libpreload hackery (syscallbuf and seccomp-bpf) but with comparable performance.  There are further interesting things that could be done with custom page-table entries.  Lingering issues
* does Dune expose rdtsc and cpuid virtualization?
* does Dune expose some kind of interrupting programmable hwtimer?
</blockquote>

== Checkpointing ==

[https://criu.org/Main_Page CRIU checkpointing of user-space Linux processes]

[http://blog.tonicdev.com/2015/09/10/time-traveling-in-node.js-notebooks.html Tonic Docker-based checkpointing for JS REPLs]

== seccomp-bpf ==

[https://github.com/tsgates/mbox/blob/master/doc/paper.pdf Mbox]